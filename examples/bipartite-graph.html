<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<style type="text/css">
	.taxon_img {
		position: absolute; top: 0; left: 0; opacity: 1.0;
	}
	.taxon_name {
		position: absolute; top: 0; left: 0; opacity: 0.8;
	}
	.taxon_img_div {
		position: relative;
	}

	table {
		display: inline-table;
	}

	td {
		text-align: center;
	}

	.source {
		stroke: #006600;
		fill:   #00cc00;
	}

	.link {
		stroke: black;
		fill:   #00cc00;
	}

	</style>
	<script src="../globi-dist.js" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">	

	var d3 = globi.d3;

	var matched_against_taxonomy = function(node) {
		return node.path && "no:match" != node.path;
	}

	var index_for_node = function(node) {
		return node.path + "_" + node.name;
	};

	var classname_for_node = function(node) {
		return node.name.replace(' ', '_');
	};

	var parse = function(response, interactions, nodes) {
		for (var i = response.length - 1; i >= 0; i--) {
			var inter = response[i];
			if (matched_against_taxonomy(inter.source) 
				&& matched_against_taxonomy(inter.target)) {

				var source = inter.source.name;

				var source_index = index_for_node(inter.source);
				nodes[source_index] = {"name": source, "id": inter.source.id, "path": inter.source.path};

				var target = inter.target.name;
				var target_index = index_for_node(inter.target);
				nodes[target_index]= {"name":target,"id":inter.target.id, "path":inter.target.path};

				var type = inter.interaction_type;
				var interact_id = source + '-' + type + '-' + target;
				interactions[interact_id] = {'source':nodes[source_index],'type':type,'target':nodes[target_index]};
			}					
		}
	};

var taxon_color_map = function() {
	var color_map = [];
	color_map['Arthropoda'] = 'red';
	color_map['Mammalia'] = 'lightblue';
	color_map['Aves'] = 'brown';
	color_map['Actinopterygii'] = 'blue';
	color_map['Arachnida'] = 'pink';
	color_map['Mollusca'] = 'orange';
	color_map['Plantae'] = 'green';
	color_map['Amphibia'] = 'violet';
	color_map['Reptilia'] = 'yellow';
	color_map['Bacteria'] = 'magenta';
	color_map['other'] = 'gray';
	return color_map;
};

var add_legend = function(legend_id, color_map, width, height) {
	var taxon_rank_colors = [];
	var i = 1;
	for (var taxon_rank in color_map) {
		taxon_rank_colors.push({"rank": taxon_rank, "color": color_map[taxon_rank], "id": i });
		i++;
	}
	
	var legend = d3.select("#" + legend_id).append("svg")
	.attr("width", width / 5)
	.attr("height", height);

	var radius = height / taxon_rank_colors.length / 4;
	var y_offset = (height - 2 * radius * taxon_rank_colors.length) / taxon_rank_colors.length / 2;
	var x_offset = width / 20;

	legend.selectAll('circle')
	.data(taxon_rank_colors)
	.enter()
	.append('circle')
	.attr("style", function(d) { return "fill:" + d.color; })
	.attr("cx", function(d) { return x_offset + radius; })
	.attr("cy", function(d) { return height/50 + radius + d.id * (y_offset + (radius * 2)); })
	.attr("r", function(d) { return radius; });

	legend.selectAll('text')
	.data(taxon_rank_colors)
	.enter()
	.append('text')
	.text(function(d) { return d.rank; })
	.style("font-size", function(d) { return height/30 + "px"; })
	.attr("x", function(d) { return x_offset * 1.4 + radius; })
	.attr("y", function(d) { return 1.2*height/50 + radius + d.id * (y_offset + (radius * 2)); });

}

var location_query = function(location) {
	var location_query = "";
	for (elem in location) {
		location_query += elem + "=" + location[elem] + "&";
	}
	return location_query;
}

var add_interaction_graph = function(location = { "nw_lat": 18.25, "nw_lng": -66.50, "se_lat": 18.24, "se_lng": -66.49}, div_ids = {"graph_id":"interaction_graph", "legend_id":"interaction_graph_legend"}, width = 1000, height = 500) {
	var svg = d3.select("#" + div_ids.graph_id).append("svg")
	.attr("width", width)
	.attr("height", height);

	var color_map = taxon_color_map();

	add_legend(div_ids.legend_id, color_map, width, height);

	
	var json_local = false;
	var json_resource = json_local ? "interactions.json" : "http://trophicgraph.com:8080/interaction?type=json.v2&" + location_query(location);

	d3.json(json_resource, 
		function(error, response) {
			if (!error) {

				var interactions = {};
				var nodes = {};

				parse(response, interactions, nodes);

				var node_array = [];

				var node_keys = [];

				var number_of_nodes = 0;
				for (var node_key in nodes) {
					number_of_nodes++; 
					node_keys.push(node_key);
				}

				node_keys.sort();

				var i = 0;
				for (var node_key in node_keys) {
					var key = node_keys[node_key];
					width_per_node = width / (number_of_nodes + 1);
					nodes[key].x = width_per_node + i * width_per_node;
					nodes[key].y = 45;
					nodes[key].radius = width_per_node;
					nodes[key].color = "pink";
					node_array.push(nodes[key]);
					i = i + 1;
				}

				interactions_array = [];
				for (var key in interactions) {
					interactions[key].source = nodes[index_for_node(interactions[key].source)];
					interactions[key].target = nodes[index_for_node(interactions[key].target)];
					interactions_array.push(interactions[key]);
				}

				var path_color = function(d) {
					var color = color_map['other'];
					for (var taxon_rank in color_map) {
						if (d.path && d.path.contains(taxon_rank)) {
							color = color_map[taxon_rank];
							break;
						}	
					}
					return color;
				};

				var node_style = function(d) {
					return "fill: " + path_color(d) + "; stroke: blue; opacity: 0.5;";
				};
				var line_style = function(d) { return "stroke:" + (d.type == 'ATE' ? "lightgreen" : "pink") + "; fill:none; opacity:0.1;"; };
				var line_style_active = function(d) { return "stroke:" + (d.type == 'ATE' ? "green" : "red") + "; fill:none; opacity:0.9;"; };


				var activate_taxa_and_links = function(d, inter_dir) {
					d3.selectAll("." + inter_dir.start + "." + classname_for_node(d)).attr("style", "fill: red; stroke: blue; opacity: 1.0;"); 
					d3.selectAll(".link." + inter_dir.start + "-" + classname_for_node(d)).attr("style", line_style_active); 
					link_array = d3.selectAll(".link." + inter_dir.start + "-" + classname_for_node(d)).data();
					var target_names = '';
					if (link_array.length > 1) {
						target_names = link_array[0][inter_dir.finish].name;
					}
					for (i=1; i < link_array.length; i++) {
						target_names += ", ";
						target_names += link_array[i][inter_dir.finish].name;
					}
					d3.selectAll("#" + inter_dir.finish + "-names").append("span").text(target_names);
					d3.selectAll("#" + inter_dir.start + "-names").append("span").text(d.name);	
				};


				var source_circle = svg.selectAll('.source')
				.data(node_array)
				.enter()
				.append("circle");


				source_circle
				.attr("class", function(d) { return "source " + classname_for_node(d); })
				.attr("style", node_style)
				.attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) { return d.y; })
				.attr("r", function(d) { return d.radius; })
				.on("mouseover", function(d) { 
					activate_taxa_and_links(d, {"start":"source","finish":"target"});
					return d.name; 
				})
				.on("mouseout", function(d) { 
					d3.selectAll(".source." + classname_for_node(d)).attr("style", node_style); 
					d3.selectAll(".link.source-" + classname_for_node(d)).attr("style", line_style); 
					d3.selectAll("#source-taxon").selectAll("span").remove();
					d3.selectAll("#source-names").selectAll("span").remove();	
					d3.selectAll("#target-names").selectAll("span").remove();	
					return d.name; 
				});	

				var target_circle = svg.selectAll('.target')
				.data(node_array)
				.enter()
				.append("circle");

				target_circle
				.attr("class", function(d) { return "target " + classname_for_node(d); })
				.attr("style", node_style)
				.attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) {return d.y + height * 0.81; })
				.attr("r", function(d) { return d.radius; })
				.on("mouseover", function(d) { 
					activate_taxa_and_links(d, {"start":"target","finish":"source"});
					return d.name; 
				})
				.on("mouseout", function(d) { 
					d3.selectAll(".target." + classname_for_node(d)).attr("style", node_style); 
					d3.selectAll(".link.target-" + classname_for_node(d)).attr("style", line_style); 
					d3.selectAll("#target-taxon").selectAll("span").remove();
					d3.selectAll("#target-names").selectAll("span").remove();	
					d3.selectAll("#source-names").selectAll("span").remove();	
					return d.name; 
				});	

				svg.selectAll(".link")
				.data(interactions_array)
				.enter()
				.append("path")
				.attr("class", function(d) { 
					return "link " + "source-" + classname_for_node(d.source) + " target-" + classname_for_node(d.target); 
				} )
				.attr("style", line_style)
				.attr('d', function(d) { return "M" + d.source.x + " " + d.source.y + " Q" + d.source.x + " " + d.source.y  + " " + d.target.x + " " + d.target.y + 0.1; } );

			}
		});
}

window.onload = function() {
	add_interaction_graph();
};

</script>
</head>
<body>
	<p>Welcome to GloBI's Proof of Concept - Bipartite graph representation source (e.g. predator) and target (e.g. prey) taxa.</p>
	<table>
		<tr>
			<td width='1000' height='100'>
				<b>source taxa</b>
				<span id="source-names"/>
				<span id="source-taxon"/>
			</td>
		</tr>
		<tr>
			<td>
				<span class="chart" id="interaction_graph"/>
			</td>
			<td>
				<span id="interaction_graph_legend"/>
			</td>
		</tr>
		<td width='1000'>
			<b>target taxa</b>
			<span id="target-names"/>
			<span id="target-taxon"/>
		</td>
	</tr>
	<tr>
		<td>

		</td>
	</tr>

</table>

</body>
</html>
